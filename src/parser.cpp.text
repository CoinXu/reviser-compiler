/**
 * @date 2020-06-16
 * @author duanxian0605@163.com
 * @description
 */

#include <parser.h>
#include <message.h>
#include <ast/stmt.h>

using namespace reviser::message;
using namespace std;

namespace reviser {
namespace compiler {

  Parser::Parser(Tokenizer tokenizer)
    : tokenizer(tokenizer), message("parser"), stmt(), current() {}

  Parser::~Parser() {}

  void Parser::Program() {
    Accept(CodeStart);

    do {
      DefStmt();
    } while (!Accept(CodeEnd));
  }

  //
  // private
  bool Parser::Accept(TokenType type) {
    if (tokenizer.Current().type == type) {
      tokenizer.Next();
      return true;
    }
    return false;
  }

  void Parser::Expect(TokenType type) {
    if (!Accept(type)) {
      message.SetLine(tokenizer.Current().start_line);
      message.SetColumn(tokenizer.Current().column_start);
      message.Runtime("syntax error: " + tokenizer.Current().text);
    }
  }

  bool Parser::LookAt(string expect) {
    return tokenizer.Current().text == expect;
  }

  string Parser::Text() {
    return tokenizer.Current().text;
  }

  TokenType Parser::Type() {
    return tokenizer.Current().type;
  }

  void Parser::DefStruct() {
    Expect(ID);
    Expect(LeftBrace);

    do {
      DefStructProperty();
    } while (Accept(Semicolon));

    Expect(RightBrace);
  }

  void Parser::DefStructProperty() {
    if (Accept(AstDecorater)) {
      do {
        DefDecorater();
      } while (Accept(AstDecorater));
    }

    DefDeclare();
  }

  void Parser::DefDecorater() {
    // TODO
  }

  void Parser::DefDeclare() {
    if (Accept(DataType)) {
      DefStructDataTypeDeclare();
    } else if (Accept(ID)) {
      DefStructEnumDeclare();
    }
  }

  void Parser::DefStructDataTypeDeclare() {
    string type = tokenizer.Previous().text;

    Expect(ID);

    if (Accept(AstAssign)) {
      string value = Text();
      TokenType token = Type();

      if (type == ReservedWordMap[ReservedWordTypeBoolean]) {
        if (value != ReservedWordMap[ReservedWordBooleanFalse]
          && value != ReservedWordMap[ReservedWordBooleanTrue]) {
          message.Runtime("expect true or false");
        } else {
          tokenizer.Next();
        }
      } else if (type == ReservedWordMap[ReservedWordTypeFloat]
        || type == ReservedWordMap[ReservedWordTypeDouble]
        || type == ReservedWordMap[ReservedWordTypeInt32]
        || type == ReservedWordMap[ReservedWordTypeInt64]
        || type == ReservedWordMap[ReservedWordTypeUint32]
        || type == ReservedWordMap[ReservedWordTypeUint64]) {
        Expect(Digit);
      } else if (type == ReservedWordMap[ReservedWordTypeString]) {
        Expect(Letter);
      }
    }
  }

  void Parser::DefStructEnumDeclare() {
    Expect(ID);
    Expect(AstAssign);
    Expect(ID);
    Expect(Connection);
    Expect(ID);
  }

  void Parser::DefEnum() {
    Expect(ID);
    Expect(LeftBrace);

    do {
      DefEnumProperty();
    } while (Accept(Comma));

    Expect(RightBrace);
  }

  void Parser::DefEnumProperty() {
    Expect(ID);

    if (Accept(AstAssign)) {
      Expect(Digit);
    }
  }

  void Parser::DefStmt() {
    if (Accept(AstStruct)) {
      DefStruct();
    } else if (Accept(AstEnum)) {
      DefEnum();
    }
  }
}; // reviser
}; // compiler
